"""Tests for temporal logic and event sequence consistency."""
import pytest

class TestEventMonotonicity:
    """Test that events follow a logical chronological order."""

    def test_timestamp_monotonicity(self, cursor):
        """Test that timestamps are non-decreasing within the same match and period."""
        cursor.execute("""
            WITH next_events AS (
                SELECT 
                    match_id,
                    period,
                    index_num,
                    timestamp,
                    LEAD(timestamp) OVER (PARTITION BY match_id, period ORDER BY index_num) as next_timestamp
                FROM events
            )
            SELECT COUNT(*)
            FROM next_events
            WHERE next_timestamp IS NOT NULL 
            AND next_timestamp < timestamp;
        """)
        violations = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM events;")
        total_events = cursor.fetchone()[0]
        
        # We allow a tiny fraction of violations in the open data due to recorded sequencing quirks
        if total_events > 0:
            assert violations / total_events < 0.001, f"Found {violations} events where timestamp decreased relative to index_num"

    def test_minute_second_monotonicity(self, cursor):
        """Test that minute/second combinations are non-decreasing within the same period."""
        cursor.execute("""
            WITH time_values AS (
                SELECT 
                    match_id,
                    period,
                    index_num,
                    (minute * 60 + second) as total_seconds,
                    LEAD(minute * 60 + second) OVER (PARTITION BY match_id, period ORDER BY index_num) as next_total_seconds
                FROM events
            )
            SELECT COUNT(*)
            FROM time_values
            WHERE next_total_seconds IS NOT NULL 
            AND next_total_seconds < total_seconds;
        """)
        violations = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM events;")
        total_events = cursor.fetchone()[0]
        
        if total_events > 0:
            assert violations / total_events < 0.001, f"Found {violations} events where minute:second decreased relative to index_num"

class TestPostStateIntegrity:
    """Test that players don't generate events after they should be off the field."""

    def test_no_events_after_red_card(self, cursor):
        """Test that players have no further events after a Red Card or Second Yellow."""
        cursor.execute("""
            WITH card_events AS (
                SELECT match_id, player_id, period, index_num
                FROM events
                WHERE (foul_committed_card IN ('Red Card', 'Second Yellow')
                   OR bad_behaviour_card IN ('Red Card', 'Second Yellow'))
            )
            SELECT COUNT(*)
            FROM events e
            JOIN card_events c ON e.match_id = c.match_id AND e.player_id = c.player_id
            WHERE (e.period > c.period) 
               OR (e.period = c.period AND e.index_num > c.index_num)
               AND e.type NOT IN ('Substitution', 'Tactical Shift'); -- Allow some system events
        """)
        violations = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM events WHERE type = 'Foul Committed' OR type = 'Bad Behaviour';")
        total_cards = cursor.fetchone()[0]
        
        if total_cards > 0:
            # StatsBomb data occasionally has late-recorded cards or post-match notations.
            assert violations < 10, f"Found {violations} events generated by players after receiving a red card"

    def test_no_events_after_substitution(self, cursor):
        """Test that players have no further events after being substituted out."""
        cursor.execute("""
            WITH sub_events AS (
                SELECT match_id, player_id, period, index_num
                FROM events
                WHERE type = 'Substitution'
            )
            SELECT COUNT(*)
            FROM events e
            JOIN sub_events s ON e.match_id = s.match_id AND e.player_id = s.player_id
            WHERE (e.period > s.period) 
               OR (e.period = s.period AND e.index_num > s.index_num);
        """)
        violations = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM events WHERE type = 'Substitution';")
        total_subs = cursor.fetchone()[0]
        
        if total_subs > 0:
            # We allow 1% noise for sub-second overlapping events in open data.
            assert violations / total_subs < 0.01, f"Found {violations} events generated by players after being substituted"
